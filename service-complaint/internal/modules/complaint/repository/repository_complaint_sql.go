// Code generated by candi v1.16.3.

package repository

import (
	"context"

	"strings"
	"time"

	"service-complaint/internal/modules/complaint/domain"
	shareddomain "service-complaint/pkg/shared/domain"

	"github.com/golangid/candi/candishared"
	"github.com/golangid/candi/tracer"

	"service-complaint/pkg/shared"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

func (r *complaintRepoSQL) FetchAll(ctx context.Context, filter *domain.FilterComplaint) (data []shareddomain.Complaint, err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "ComplaintRepoSQL:FetchAll")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	if filter.OrderBy == "" {
		filter.OrderBy = "created_at"
	}

	db := r.setFilterComplaint(shared.SetSpanToGorm(ctx, r.readDB), filter).Order(clause.OrderByColumn{
		Column: clause.Column{Name: filter.OrderBy},
		Desc:   strings.ToUpper(filter.Sort) == "DESC",
	})
	if filter.Limit > 0 {
		db = db.Limit(filter.Limit).Offset(filter.CalculateOffset())
	}
	err = db.Find(&data).Error
	return
}

func (r *complaintRepoSQL) Count(ctx context.Context, filter *domain.FilterComplaint) (count int) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "ComplaintRepoSQL:Count")
	defer trace.Finish()

	var total int64
	r.setFilterComplaint(shared.SetSpanToGorm(ctx, r.readDB), filter).Model(&shareddomain.Complaint{}).Count(&total)
	count = int(total)

	trace.Log("count", count)
	return
}

func (r *complaintRepoSQL) Find(ctx context.Context, filter *domain.FilterComplaint) (result shareddomain.Complaint, err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "ComplaintRepoSQL:Find")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	err = r.setFilterComplaint(shared.SetSpanToGorm(ctx, r.readDB), filter).First(&result).Error
	return
}

func (r *complaintRepoSQL) Save(ctx context.Context, data *shareddomain.Complaint, updateOptions ...candishared.DBUpdateOptionFunc) (err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "ComplaintRepoSQL:Save")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	db := r.writeDB
	if tx, ok := candishared.GetValueFromContext(ctx, candishared.ContextKeySQLTransaction).(*gorm.DB); ok {
		db = tx
	}
	data.UpdatedAt = time.Now()
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	if data.ID == 0 {
		err = shared.SetSpanToGorm(ctx, db).Omit(clause.Associations).Create(data).Error
	} else {
		err = shared.SetSpanToGorm(ctx, db).Model(data).Omit(clause.Associations).Updates(r.updateTools.ToMap(data, updateOptions...)).Error
	}
	return
}

func (r *complaintRepoSQL) Delete(ctx context.Context, filter *domain.FilterComplaint) (err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "ComplaintRepoSQL:Delete")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	db := r.writeDB
	if tx, ok := candishared.GetValueFromContext(ctx, candishared.ContextKeySQLTransaction).(*gorm.DB); ok {
		db = tx
	}
	err = r.setFilterComplaint(shared.SetSpanToGorm(ctx, db), filter).Delete(&shareddomain.Complaint{}).Error
	return
}

func (r *complaintRepoSQL) AggregateStatuses(ctx context.Context, filter *domain.FilterComplaint) (result []domain.MetaComplaintStatusAggs, err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "ComplaintRepoSQL:AggregateStatuses")
	defer trace.Finish()

	err = r.setFilterComplaint(shared.SetSpanToGorm(ctx, r.readDB), filter).
		Model(&shareddomain.Complaint{}).
		Select("status, count(status) as count").
		Group("status").
		Scan(&result).Error

	return
}

func (r *complaintRepoSQL) setFilterComplaint(db *gorm.DB, filter *domain.FilterComplaint) *gorm.DB {

	if filter.ID != nil {
		db = db.Where("id = ?", *filter.ID)
	}
	if filter.Search != "" {
		db = db.Where("(title ILIKE '%%' || ? || '%%' OR complain_no ILIKE '%%' || ? || '%%')", filter.Search, filter.Search)
	}

	if filter.ComplaintNum != "" {
		db = db.Where("complain_no = ?", filter.ComplaintNum)
	}

	if filter.Status != "" {
		db = db.Where("status = ?", filter.Status)
	}

	if filter.CategoryID != "" {
		db = db.Where("category_id = ?", filter.CategoryID)
	}

	if filter.UserID != 0 {
		db = db.Where("user_id = ?", filter.UserID)
	}

	if filter.SectorID != 0 {
		db = db.Joins(`INNER JOIN "complaint_category" on "complaints"."category_id" = "complaint_category"."id"`)
		// db = db.Joins("Category")
		db = db.Where(`"complaint_category"."sector_id" = ?`, filter.SectorID)
	}

	for _, preload := range filter.Preloads {
		db = db.Preload(preload)
	}

	return db
}
