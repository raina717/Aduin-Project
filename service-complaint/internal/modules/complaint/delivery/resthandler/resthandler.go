// Code generated by candi v1.16.3.

package resthandler

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"service-complaint/internal/modules/complaint/domain"
	"service-complaint/pkg/shared/usecase"

	"github.com/golangid/candi/candihelper"
	"github.com/golangid/candi/candishared"
	restserver "github.com/golangid/candi/codebase/app/rest_server"
	"github.com/golangid/candi/codebase/factory/dependency"
	"github.com/golangid/candi/codebase/interfaces"
	"github.com/golangid/candi/tracer"
	"github.com/golangid/candi/wrapper"
)

// RestHandler handler
type RestHandler struct {
	mw        interfaces.Middleware
	uc        usecase.Usecase
	validator interfaces.Validator
}

// NewRestHandler create new rest handler
func NewRestHandler(uc usecase.Usecase, deps dependency.Dependency) *RestHandler {
	return &RestHandler{
		uc: uc, mw: deps.GetMiddleware(), validator: deps.GetValidator(),
	}
}

// Mount handler with root "/"
// handling version in here
func (h *RestHandler) Mount(root interfaces.RESTRouter) {
	v1Complaint := root.Group(candihelper.V1 + "/complaint")

	v1Complaint.POST("/", h.createComplaint, h.mw.HTTPBearerAuth)
	v1Complaint.PUT("/", h.updateComplaint, h.mw.HTTPBearerAuth)
	v1Complaint.POST("/response", h.addResponse, h.mw.HTTPBearerAuth)
	v1Complaint.POST("/comment", h.addComment, h.mw.HTTPBearerAuth)
	v1Complaint.PUT("/like/:id", h.putLike, h.mw.HTTPBearerAuth)
	v1Complaint.PUT("/share/:id", h.incrementShare, h.mw.HTTPBearerAuth)

	v1Complaint.GET("/categories", h.getCategories)
	v1Complaint.GET("/:id", h.getDetailComplaintByID, h.mw.HTTPBearerAuth)
	v1Complaint.GET("/", h.getAllComplaint)

	// v1Complaint.DELETE("/:id", h.deleteComplaint, h.mw.HTTPPermissionACL("deleteComplaint"))

	storage := root.Group("/storage")
	storage.POST("/upload", h.upload, h.mw.HTTPBearerAuth)
	storage.GET("/evidences/:complaint_id/:filename", h.getEvidence)
}

func (h *RestHandler) createComplaint(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:CreateComplaint")
	defer trace.Finish()

	body, _ := io.ReadAll(req.Body)
	// if err := h.validator.ValidateDocument("complaint/save", body); err != nil {
	// 	wrapper.NewHTTPResponse(http.StatusBadRequest, "Failed validate payload", err).JSON(rw)
	// 	return
	// }

	var payload domain.AddComplaint
	if err := json.Unmarshal(body, &payload); err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	tokenClaim := candishared.ParseTokenClaimFromContext(ctx)
	payload.UserID, _ = strconv.Atoi(tokenClaim.Subject)

	err := h.uc.Complaint().CreateComplaint(ctx, &payload)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusCreated, "Success").JSON(rw)
}

func (h *RestHandler) addResponse(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:addResponse")
	defer trace.Finish()

	body, _ := io.ReadAll(req.Body)

	var payload domain.AddComplaintResponse
	if err := json.Unmarshal(body, &payload); err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	tokenClaim := candishared.ParseTokenClaimFromContext(ctx)
	payload.UserID, _ = strconv.Atoi(tokenClaim.Subject)

	err := h.uc.Complaint().AddResponse(ctx, &payload)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusCreated, "Success").JSON(rw)
}

func (h *RestHandler) addComment(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:addComment")
	defer trace.Finish()

	var payload domain.AddComment
	body, _ := io.ReadAll(req.Body)

	if err := json.Unmarshal(body, &payload); err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	tokenClaim := candishared.ParseTokenClaimFromContext(ctx)
	payload.UserID, _ = strconv.Atoi(tokenClaim.Subject)

	err := h.uc.Complaint().AddComment(ctx, &payload)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusCreated, "Success").JSON(rw)
}

func (h *RestHandler) incrementShare(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:incrementShare")
	defer trace.Finish()

	err := h.uc.Complaint().IncrementShare(ctx, candihelper.ToInt(restserver.URLParam(req, "id")))
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusCreated, "Success").JSON(rw)
}

func (h *RestHandler) putLike(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:putLike")
	defer trace.Finish()

	var payload domain.PutLike
	payload.ComplaintID = candihelper.ToInt(restserver.URLParam(req, "id"))

	tokenClaim := candishared.ParseTokenClaimFromContext(ctx)
	payload.UserID, _ = strconv.Atoi(tokenClaim.Subject)

	err := h.uc.Complaint().PutLike(ctx, &payload)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusCreated, "Success").JSON(rw)
}

func (h *RestHandler) getAllComplaint(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:GetAllComplaint")
	defer trace.Finish()

	auth := req.Header.Get("Authorization")
	if auth == "" || len(strings.Split(auth, " ")) < 2 {
		wrapper.NewHTTPResponse(http.StatusUnauthorized, "Unauthorized").JSON(rw)
		return
	}

	var filter domain.FilterComplaint
	if err := candihelper.ParseFromQueryParam(req.URL.Query(), &filter); err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, "Failed parse filter", err).JSON(rw)
		return
	}

	authHeader := strings.Split(auth, " ")
	if authHeader[0] == "Bearer" {
		tokenClaim, err := h.uc.User().ValidateToken(ctx, authHeader[1])
		if err != nil {
			wrapper.NewHTTPResponse(http.StatusUnauthorized, "Unauthorized", err).JSON(rw)
			return
		}

		filter.UserID, _ = strconv.Atoi(tokenClaim.Subject)
	} else if authHeader[0] == "Basic" {
		err := h.mw.Basic(ctx, authHeader[1])
		if err != nil {
			wrapper.NewHTTPResponse(http.StatusUnauthorized, "Unauthorized", err).JSON(rw)
			return
		}

		filter.UserID = 0
		filter.ShowCurrentUser = false
	}

	// if err := h.validator.ValidateDocument("complaint/get_all", filter); err != nil {
	// 	wrapper.NewHTTPResponse(http.StatusBadRequest, "Failed validate filter", err).JSON(rw)
	// 	return
	// }

	data, meta, err := h.uc.Complaint().GetAllComplaint(ctx, filter)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	message := "Success"
	resp := wrapper.NewHTTPResponse(http.StatusOK, message, data)
	resp.Meta = meta
	resp.JSON(rw)
}

func (h *RestHandler) getCategories(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:getCategories")
	defer trace.Finish()

	data, err := h.uc.Complaint().GetCategories(ctx)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	message := "Success"
	wrapper.NewHTTPResponse(http.StatusOK, message, data).JSON(rw)
}

func (h *RestHandler) getDetailComplaintByID(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:GetDetailComplaintByID")
	defer trace.Finish()

	var payload domain.GetDetailComplaint
	tokenClaim := candishared.ParseTokenClaimFromContext(ctx)

	payload.UserID, _ = strconv.Atoi(tokenClaim.Subject)
	payload.ComplaintID, _ = strconv.Atoi(restserver.URLParam(req, "id"))

	data, err := h.uc.Complaint().GetDetailComplaint(ctx, payload)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusOK, "Success", data).JSON(rw)
}

func (h *RestHandler) updateComplaint(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:UpdateComplaint")
	defer trace.Finish()

	body, _ := io.ReadAll(req.Body)
	// if err := h.validator.ValidateDocument("complaint/save", body); err != nil {
	// 	wrapper.NewHTTPResponse(http.StatusBadRequest, "Failed validate payload", err).JSON(rw)
	// 	return
	// }

	var payload domain.UpdateComplaint
	if err := json.Unmarshal(body, &payload); err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	tokenClaim := candishared.ParseTokenClaimFromContext(ctx)
	payload.ChangedBy, _ = strconv.Atoi(tokenClaim.Subject)
	err := h.uc.Complaint().UpdateComplaint(ctx, &payload)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusOK, "Success").JSON(rw)
}

func (h *RestHandler) deleteComplaint(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:DeleteComplaint")
	defer trace.Finish()

	id, _ := strconv.Atoi(restserver.URLParam(req, "id"))
	if err := h.uc.Complaint().DeleteComplaint(ctx, id); err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusOK, "Success").JSON(rw)
}

func (h *RestHandler) upload(rw http.ResponseWriter, req *http.Request) {
	trace, ctx := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:upload")
	defer trace.Finish()

	fileForm, fileHeader, err := req.FormFile("file")
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	payload := domain.UploadRequest{
		Filename: fileHeader.Filename,
		FileSize: fileHeader.Size,

		ContentType: fileHeader.Header.Get("Content-Type"),
	}

	payload.ComplaintID, _ = strconv.Atoi(req.FormValue("complaint_id"))

	tokenClaim := candishared.ParseTokenClaimFromContext(ctx)
	payload.UserID, _ = strconv.Atoi(tokenClaim.Subject)

	resp, err := h.uc.Complaint().Upload(ctx, &payload, fileForm)
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	wrapper.NewHTTPResponse(http.StatusCreated, "Success", resp).JSON(rw)
}

func (h *RestHandler) getEvidence(rw http.ResponseWriter, req *http.Request) {
	trace, _ := tracer.StartTraceWithContext(req.Context(), "ComplaintDeliveryREST:getEvidence")
	defer trace.Finish()

	filename := restserver.URLParam(req, "filename")
	complaintID := restserver.URLParam(req, "complaint_id")

	dir, err := os.Getwd()
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	file, err := os.Open(filepath.Join(dir, "storage/evidences", complaintID, filename))
	if err != nil {
		wrapper.NewHTTPResponse(http.StatusBadRequest, err.Error()).JSON(rw)
		return
	}

	defer file.Close()

	contentDisposition := fmt.Sprintf("attachment; filename=%s", filename)
	rw.Header().Set("Content-Disposition", contentDisposition)

	if _, err := io.Copy(rw, file); err != nil {
		wrapper.NewHTTPResponse(http.StatusInternalServerError, err.Error()).JSON(rw)
		return
	}

}
